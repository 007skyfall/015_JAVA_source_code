1、变量的声明格式
//声明和初始化一起
数据类型  变量名 = 变量值;
//声明
数据类型  变量名;

2、Java的数据类型
基本数据类型：byte,short,char,int,long,float,double,boolean
引用数据类型：枚举、数组、接口、类
	类：java.lang.String，java.lang.System，java.util.Arrays，
		java.lang.Math,java.util.Scanner，java.lang.Object等
	接口：java.lang.Comparable，java.util.Comparator
	
3、变量的三要素
数据类型 变量名 变量值

变量的数据类型：所有的Java类型都可以

变量的分类：
成员变量：实例变量（没有static）、类变量（有static)
局部变量：

如何区别成员变量和局部变量？
局部变量的声明位置：（1）方法体里（2）形参（3）代码块里面
成员变量的声明位置：类中方法和代码块外

内存中存储的位置：
局部变量：栈
类变量：方法区
实例变量：堆

继续整理：
局部变量的前面可以有哪些修饰符？
成员变量的前面可以有哪些修饰符？

生命周期、作用域？


4、数组的声明格式
数据类型[] 数组名;

数组的元素的类型：所有Java类型都可以

5、数组的动态初始化格式
//声明和初始化一起
数据类型[] 数组名 = new 数据类型[长度];
//动态初始化
数组名 = new 数据类型[长度];

6、数组的静态初始化格式
//静态初始化
数组名 = new 数据类型[]{值列表};

//声明和静态初始化一起
数据类型[] 数组名 = {值列表};

7、属性的声明格式
【修饰符】 数据类型 属性名;

【修饰符】：private,缺省,protected,public,static,final等

8、类的声明格式
【修饰符】 class 类名{

}

【修饰符】：
	最外面的类：public,缺省,abstract,final
	内部类：private,缺省,protected,public,static,abstract,final
	
9、接口的声明格式
【修饰符】 interface 接口名{
}	

【修饰符】：public，缺省

接口的特点：
（1）接口不能实例化
（2）一个类可以实现多个接口
（3）接口中只有
A：全局的静态的常量：public static final
B：公共的抽象的方法
C：公共的默认的方法
D：公共的静态的方法
E：内部接口
（4）接口可以继承多个接口

10、构造器的声明格式
【修饰符】 类名(){
}
【修饰符】 类名(形参列表){
	
}

11、枚举的声明格式
【修饰符】 enum 枚举名{
	常量对象列表 ;
	其他成员列表
}

枚举的常量对象列表必须在枚举类的首行。

首行：
(1)this()或this(实参列表)必须在构造器的首行
(2)super()或super(实参列表)必须在子类构造器的首行
(3)package语句必须在源文件的首行
(4)枚举的常量对象列表必须在枚举类的首行。

12、匿名内部类的声明格式
new 父类(){
}//通过父类的无参构造
new 父类(实参列表){
}//通过父类的有参构造
new 父接口(){
}

13、双分支结构的语法格式
if(条件表达式){
	当表达式为true需要执行的语句块;
}else{
	当表达式为false需要执行的语句块;
}

14、for循环的语法格式
for(初始化表达式; 循环条件表达式; 迭代表达式){
	需要重复执行的循环体语句块;
}

15、foreach循环的语法格式
for(元素的数据类型  元素名 : 数组名){

}

for循环和foreach循环的区别：
foreach循环更简洁，增强版for循环，没有下标信息，不能修改元素的值或个数。
foreach不能修改元素值（如果是基本数据类型，不能改数据值，如果是引用数据类型，不能改地址值，如果是引用数据类型，属性值可以改）

16、do...while循环的语法格式
do{
	需要重复执行的循环体语句块;
}while(循环条件表达式);


17、while循环的语法格式
while(循环条件表达式){
	需要重复执行的循环体语句块;
}

do..while和while的区别，do...while至少执行一次循环体语句，while有可能一次都不执行。

18、switch的语法格式
switch(表达式){
case 常量值1:
	[break;]
case 常量值2:
	[break;]
....
default:
	[break;]
}


表达式的类型要求：4种基本数据类型（byte,short,int,char），
				JDK1.5之后可以支持枚举类型，JDK1.7之后可以支持String类型.
				
凡是写条件表达式的地方，都要boolean类型。

19、无参无返回值方法的声明格式和调用格式

无参无返回值方法的声明格式：
【修饰符】 void 方法名(){
}

无参无返回值方法的调用格式：
对象.方法名();

错误：
变量 = 对象.方法名();
System.out.println(对象.方法名());

20、无参有返回值方法的声明格式和调用格式
无参有返回值方法的声明格式：
【修饰符】 返回值类型 方法名(){
	return 返回值;
}

返回值类型：所有的Java类型

无参有返回值方法的调用格式：
变量 = 对象.方法名();//用变量接收返回值
System.out.println(对象.方法名());//直接打印返回值

21、有参无返回值方法的声明格式和调用格式
有参无返回值方法的声明格式：
【修饰符】 void 方法名(形参列表){
}
有参无返回值方法的调用格式：
对象.方法名(实参列表);

实参列表必须与形参列表的类型、个数、顺序一致

22、有参有返回值方法的声明格式和调用格式
有参有返回值方法的声明格式：
【修饰符】 返回值类型 方法名(形参列表){
	return 返回值;
}
有参有返回值方法的调用格式：
变量 = 对象.方法名(实参列表);

23、类继承的声明格式
【修饰符】 class 子类 extends 父类{

}

24、接口继承的格式
【修饰符】 接口名 extends 接口列表{
}

25、类实现接口的声明格式
【修饰符】 class 类名 implements 接口列表{
}

【修饰符】 class 类名 extends 父类 implements 接口列表{
}

26、创建对象的声明格式
new 构造器()  //调用无参构造

new 构造器(实参列表)  //调用有参构造
